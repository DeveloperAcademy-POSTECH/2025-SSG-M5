
- **Static Dispatch(정적 디스패치)**
    - 메서드 호출이 **컴파일 시점**에 결정됨
    - 실행 시에는 이미 어떤 함수가 호출될지 결정되어 있어, 바로 해당 함수의 주소로 점프
    - **성능상 이점**: 컴파일러가 인라이닝 등 최적화 가능, 오버헤드가 거의 없음
- **Dynamic Dispatch(동적 디스패치)**
    - 메서드 호출이 **런타임 시점**에 결정됨
    - 실행 시, 객체의 실제 타입을 확인하고, **vTable(virtual method table)** 등 간접 참조를 통해 함수 주소를 찾아 호출
    - **성능상 손해**: 런타임에 함수 주소를 찾아야 하므로 오버헤드 발생, 인라이닝 등 최적화가 제한됨

---

### **2. 동작 방식**

|구분|Static Dispatch|Dynamic Dispatch|
|---|---|---|
|결정 시점|컴파일 타임|런타임|
|호출 방식|직접 호출(Direct Call)|간접 호출(Indirect Call, vTable)|
|대표 예시|struct, enum, final class|class(상속, 오버라이드), protocol|
|성능|빠름, 최적화 용이|느림, 오버헤드 존재|
|다형성|불가(상속 불가)|가능(상속, 오버라이드, 다형성)|

---

### **3. Swift에서의 적용**

- **struct, enum (값 타입)**
    - 상속/오버라이드 불가 → 항상 Static Dispatch 사용
    - 컴파일러가 메서드 호출을 미리 결정, 최적화 가능[2][3][7][1]
- **class (참조 타입)**
    - 상속/오버라이드 가능 → 기본적으로 Dynamic Dispatch 사용
    - 런타임에 vTable을 통해 실제 메서드 결정
    - 단, `final` 키워드로 상속/오버라이드 불가를 명시하면 Static Dispatch로 최적화 가능[3][6][1]
- **protocol**
    - 프로토콜 타입으로 사용할 때 동적 디스패치(Protocol Witness Table 사용)[1]
    - 제네릭으로 사용할 때는 정적 디스패치(특수화 가능)[1]

---

### **4. 실무에서의 의미와 주의점**

- Static Dispatch는 **성능상 이점**이 크므로, 상속/다형성이 필요 없는 경우 struct, enum, final class를 적극 활용
- Dynamic Dispatch는 **유연한 설계(다형성)**가 필요한 경우에만 사용
- 불필요한 동적 디스패치는 오버헤드만 늘리므로, `final`, `private` 등으로 정적 디스패치 유도 가능[6][3]
- 메서드 체인이 길어질수록 Static Dispatch의 최적화 효과가 커짐[1]

---

### **5. 한 줄 요약**

> Static Dispatch는 "컴파일 타임에 함수가 결정되어 빠르고 최적화에 유리",
> 
> Dynamic Dispatch는 "런타임에 함수가 결정되어 유연하지만 오버헤드가 발생"합니다.
> 
> Swift에서는 상황에 따라 이 두 가지 방식을 적절히 선택해 성능과 설계 유연성을 조절합니다[1][2][3][5][7].